{"version":3,"sources":["webpack:///./src/components/parts/FeedbackForm.vue?0018","webpack:///./src/views/Contact.vue?a69f","webpack:///./node_modules/@vue-leaflet/vue-leaflet/dist/vue-leaflet.esm.js","webpack:///./src/components/parts/Map.vue?e6e2","webpack:///./src/views/Contact.vue","webpack:///./src/components/parts/Map.vue","webpack:///./src/components/parts/Map.vue?6b88","webpack:///./src/components/parts/FeedbackForm.vue","webpack:///./src/components/parts/FeedbackForm.vue?d253","webpack:///./src/views/Contact.vue?7ff6"],"names":["debounce","fn","time","timeout","args","context","this","clearTimeout","setTimeout","apply","capitalizeFirstLetter","string","charAt","toUpperCase","slice","propsBinder","methods","leafletElement","props","key","setMethodName","newVal","oldVal","remapEvents","contextAttrs","result","attrName","startsWith","eventName","toLocaleLowerCase","resetWebpackIcon","async","Icon","modules","Promise","all","Default","prototype","_getIconUrl","mergeOptions","iconRetinaUrl","default","iconUrl","shadowUrl","provideLeafletWrapper","methodName","wrapped","console","warn","wrapper","value","updateLeafletWrapper","leafletMethod","WINDOW_OR_GLOBAL","self","global","undefined","GLOBAL_LEAFLET_OPT","options","type","Object","setup","props$1","pane","String","attribution","name","custom","layerType","visible","Boolean","setup$1","leafletRef","addLayer","removeLayer","componentOptions","componentMethods","addThisLayer","leafletObject","removeThisLayer","val","old","attributionControl","$parent","removeAttribution","addAttribution","isVisible","bindPopup","bindTooltip","tooltip","getTooltip","unbindTooltip","popup","getPopup","unbindPopup","emit","render","ready","slots","style","display","props$2","interactive","bubblingMouseEvents","props$3","stroke","color","weight","Number","opacity","lineCap","lineJoin","dashArray","dashOffset","fill","fillColor","fillOpacity","fillRule","className","props$4","latLng","Array","radius","props$6","position","setup$6","setPosition","remove","render$1","ref","props$8","collapsed","autoZIndex","hideSingleBase","sortLayers","sortFunction","Function","setup$8","controlOptions","layer","addBaseLayer","addOverlay","script$4","useGlobalLeaflet","registerLayerControl","control","L","layers","props$b","props$e","zIndex","tileSize","noWrap","minZoom","maxZoom","setup$e","layerOptions","layerMethods","props$f","iconSize","iconAnchor","popupAnchor","tooltipAnchor","shadowRetinaUrl","shadowSize","shadowAnchor","bgPos","script$d","emits","center","bounds","maxBounds","zoom","paddingBottomRight","paddingTopLeft","padding","worldCopyJump","crs","maxBoundsViscosity","inertia","inertiaDeceleration","inertiaMaxSpeed","easeLinearity","zoomAnimation","zoomAnimationThreshold","fadeAnimation","markerZoomAnimation","noBlockingAnimations","root","blueprint","layersToAdd","layersInControl","registerControl","eventHandlers","getZoom","getCenter","getBounds","e","find","l","updateVisibleProp","map","CRS","latLngBounds","DomEvent","beforeMapMount","error","message","optionsCrs","EPSG3857","layerControl","push","exist","_leaflet_id","filter","lControlLayer","forEach","lControl","addControl","setZoom","animate","prevBounds","fitBounds","newBounds","isValid","oldBounds","lastSetBounds","boundsChanged","equals","fitBoundsOptions","newCenter","oldCenter","lastSetCenter","lat","lng","panTo","listeners","attrs","on","moveEndHandler","overlayAddHandler","overlayRemoveHandler","width","height","$slots","props$h","draggable","icon","zIndexOffset","setup$g","dragging","enable","disable","event","latlng","oldLatLng","getLatLng","setLatLng","script$e","getElement","html","innerHTML","newIcon","setIcon","marker","latLngSync","props$i","latLngs","smoothFactor","noClip","props$j","props$k","content","setup$j","setContent","render$2","props$n","tms","subdomains","detectRetina","url","setup$m","gridLayerOptions","gridLayerMethods","script$j","tileLayer","props$o","setup$n","script$k","class","id","log","lat-lng","components","LMap","LTileLayer","LMarker","LControlLayers","LTooltip","data","a","__exports__","validateAndSend","placeholder","email","phone","checkPhoneLength","rows","directives","maska","BOT_TOKEN","CHAT_ID","length","validateEmail","regexp","match","validateForm","valid","err_text","$toast","join","text","encodeURI","get","then","resp","ok","success","description","catch","err","Map","FeedbackForm"],"mappings":"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","file":"js/chunk-31f9e160.4cd2a307.js","sourcesContent":["export * from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--9-oneOf-1-0!../../../node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!../../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--9-oneOf-1-2!../../../node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader-v16/dist/index.js??ref--1-1!./FeedbackForm.vue?vue&type=style&index=0&id=72e76be5&lang=scss&scoped=true\"","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--9-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--9-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../node_modules/vue-loader-v16/dist/index.js??ref--1-1!./Contact.vue?vue&type=style&index=0&id=7f61ab8d&lang=scss&scoped=true\"","import { watch, ref, provide, h, inject, onUnmounted, onBeforeUnmount, onMounted, nextTick, render as render$3, reactive, computed } from 'vue';\n\nconst debounce = (fn, time) => {\n  let timeout;\n\n  return function (...args) {\n    const context = this;\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n    timeout = setTimeout(() => {\n      fn.apply(context, args);\n      timeout = null;\n    }, time);\n  };\n};\n\nconst capitalizeFirstLetter = (string) => {\n  if (!string || typeof string.charAt !== \"function\") {\n    return string;\n  }\n  return string.charAt(0).toUpperCase() + string.slice(1);\n};\n\nconst propsBinder = (methods, leafletElement, props) => {\n  for (const key in props) {\n    const setMethodName = \"set\" + capitalizeFirstLetter(key);\n    if (methods[setMethodName]) {\n      watch(\n        () => props[key],\n        (newVal, oldVal) => {\n          methods[setMethodName](newVal, oldVal);\n        }\n      );\n    } else if (leafletElement[setMethodName]) {\n      watch(\n        () => props[key],\n        (newVal) => {\n          leafletElement[setMethodName](newVal);\n        }\n      );\n    }\n  }\n};\n\nconst remapEvents = (contextAttrs) => {\n  const result = {};\n  for (const attrName in contextAttrs) {\n    if (\n      attrName.startsWith(\"on\") &&\n      !attrName.startsWith(\"onUpdate\") &&\n      attrName !== \"onReady\"\n    ) {\n      const eventName = attrName.slice(2).toLocaleLowerCase();\n      result[eventName] = contextAttrs[attrName];\n    }\n  }\n  return result;\n};\n\nconst resetWebpackIcon = async (Icon) => {\n  const modules = await Promise.all([\n    import('leaflet/dist/images/marker-icon-2x.png'),\n    import('leaflet/dist/images/marker-icon.png'),\n    import('leaflet/dist/images/marker-shadow.png'),\n  ]);\n\n  delete Icon.Default.prototype._getIconUrl;\n\n  Icon.Default.mergeOptions({\n    iconRetinaUrl: modules[0].default,\n    iconUrl: modules[1].default,\n    shadowUrl: modules[2].default,\n  });\n};\n\n/**\n * Wraps a placeholder function and provides it with the given name.\n * The wrapper can later be updated with {@link updateLeafletWrapper}\n * to provide a different function.\n *\n * @param {String} methodName Key used to provide the wrapper function\n */\nconst provideLeafletWrapper = (methodName) => {\n  const wrapped = ref(() =>\n    console.warn(`Method ${methodName} has been invoked without being replaced`)\n  );\n  const wrapper = (...args) => wrapped.value(...args);\n  // eslint-disable-next-line vue/no-ref-as-operand\n  wrapper.wrapped = wrapped;\n  provide(methodName, wrapper);\n\n  return wrapper;\n};\n\n/**\n * Change the function that will be executed when an injected Leaflet wrapper\n * is invoked.\n *\n * @param {*} wrapper Provided wrapper whose wrapped function is to be updated\n * @param {function} leafletMethod New method to be wrapped by the wrapper\n */\nconst updateLeafletWrapper = (wrapper, leafletMethod) =>\n  (wrapper.wrapped.value = leafletMethod);\n\nconst WINDOW_OR_GLOBAL =\n  (typeof self === \"object\" && self.self === self && self) ||\n  (typeof global === \"object\" && global.global === global && global) ||\n  undefined;\n\nconst GLOBAL_LEAFLET_OPT = \"useGlobalLeaflet\";\n\nconst props = {\n  options: {\n    type: Object,\n    default: () => ({}),\n  },\n};\n\nconst setup = (props) => {\n  return { options: props.options, methods: {} };\n};\n\nconst props$1 = {\n  ...props,\n  pane: {\n    type: String,\n    default: \"overlayPane\",\n  },\n  attribution: {\n    type: String,\n    default: null,\n  },\n  name: {\n    type: String,\n    custom: true,\n    default: undefined,\n  },\n  layerType: {\n    type: String,\n    custom: true,\n    default: undefined,\n  },\n  visible: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n};\n\nconst setup$1 = (props, leafletRef, context) => {\n  const addLayer = inject(\"addLayer\");\n  const removeLayer = inject(\"removeLayer\");\n  const {\n    options: componentOptions,\n    methods: componentMethods,\n  } = setup(props);\n\n  const options = {\n    ...componentOptions,\n    attribution: props.attribution,\n    pane: props.pane,\n  };\n\n  const addThisLayer = () => addLayer({ leafletObject: leafletRef.value });\n  const removeThisLayer = () =>\n    removeLayer({ leafletObject: leafletRef.value });\n\n  const methods = {\n    ...componentMethods,\n    setAttribution(val, old) {\n      const attributionControl = this.$parent.leafletObject.attributionControl;\n      attributionControl.removeAttribution(old).addAttribution(val);\n    },\n    setName() {\n      removeThisLayer();\n      if (props.visible) {\n        addThisLayer();\n      }\n    },\n    setLayerType() {\n      removeThisLayer();\n      if (props.visible) {\n        addThisLayer();\n      }\n    },\n    setVisible(isVisible) {\n      if (leafletRef.value) {\n        if (isVisible) {\n          addThisLayer();\n        } else {\n          removeThisLayer();\n        }\n      }\n    },\n    bindPopup({ leafletObject }) {\n      leafletRef.value.bindPopup(leafletObject);\n    },\n    bindTooltip({ leafletObject }) {\n      leafletRef.value.bindTooltip(leafletObject);\n    },\n    unbindTooltip() {\n      const tooltip = leafletRef.value ? leafletRef.value.getTooltip() : null;\n      if (tooltip) {\n        tooltip.unbindTooltip();\n      }\n    },\n    unbindPopup() {\n      const popup = leafletRef.value ? leafletRef.value.getPopup() : null;\n      if (popup) {\n        popup.unbindPopup();\n      }\n    },\n    updateVisibleProp(value) {\n      /**\n       * Triggers when the visible prop needs to be updated\n       * @type {boolean}\n       * @property {boolean} value - value of the visible property\n       */\n      context.emit(\"update:visible\", value);\n    },\n  };\n\n  provide(\"bindPopup\", methods.bindPopup);\n  provide(\"bindTooltip\", methods.bindTooltip);\n  provide(\"unbindTooltip\", methods.unbindTooltip);\n  provide(\"unbindPopup\", methods.unbindPopup);\n\n  onUnmounted(() => {\n    methods.unbindPopup();\n    methods.unbindTooltip();\n    removeThisLayer();\n  });\n\n  return { options, methods };\n};\n\nconst render = (ready, slots) => {\n  if (ready && slots.default) {\n    return h(\"div\", { style: { display: \"none\" } }, slots.default());\n  }\n};\n\nconst props$2 = {\n  ...props,\n  interactive: {\n    type: Boolean,\n    default: true,\n  },\n  bubblingMouseEvents: {\n    type: Boolean,\n    default: true,\n  },\n};\n\nconst setup$2 = (props) => {\n  const { options: componentOptions, methods } = setup(props);\n  const options = {\n    ...componentOptions,\n    interactive: props.interactive,\n    bubblingMouseEvents: props.bubblingMouseEvents,\n  };\n\n  return { options, methods };\n};\n\nconst props$3 = {\n  ...props$1,\n  ...props$2,\n  stroke: {\n    type: Boolean,\n    custom: true,\n    default: true,\n  },\n  color: {\n    type: String,\n    custom: true,\n    default: \"#3388ff\",\n  },\n  weight: {\n    type: Number,\n    custom: true,\n    default: 3,\n  },\n  opacity: {\n    type: Number,\n    custom: true,\n    default: 1.0,\n  },\n  lineCap: {\n    type: String,\n    custom: true,\n    default: \"round\",\n  },\n  lineJoin: {\n    type: String,\n    custom: true,\n    default: \"round\",\n  },\n  dashArray: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  dashOffset: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  fill: {\n    type: Boolean,\n    custom: true,\n    default: false,\n  },\n  fillColor: {\n    type: String,\n    custom: true,\n    default: \"#3388ff\",\n  },\n  fillOpacity: {\n    type: Number,\n    custom: true,\n    default: 0.2,\n  },\n  fillRule: {\n    type: String,\n    custom: true,\n    default: \"evenodd\",\n  },\n  className: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n};\n\nconst setup$3 = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    props,\n    leafletRef,\n    context\n  );\n  const {\n    options: interactiveLayerOptions,\n    methods: interactiveLayerMethods,\n  } = setup$2(props);\n\n  const removeLayer = inject(\"removeLayer\");\n\n  const options = {\n    ...layerOptions,\n    ...interactiveLayerOptions,\n    stroke: props.stroke,\n    color: props.color,\n    weight: props.weight,\n    opacity: props.opacity,\n    lineCap: props.lineCap,\n    lineJoin: props.lineJoin,\n    dashArray: props.dashArray,\n    dashOffset: props.dashOffset,\n    fill: props.fill,\n    fillColor: props.fillColor,\n    fillOpacity: props.fillOpacity,\n    fillRule: props.fillRule,\n    className: props.className,\n  };\n  const methods = {\n    ...layerMethods,\n    ...interactiveLayerMethods,\n    setStroke(stroke) {\n      leafletRef.value.setStyle({ stroke });\n    },\n    setColor(color) {\n      leafletRef.value.setStyle({ color });\n    },\n    setWeight(weight) {\n      leafletRef.value.setStyle({ weight });\n    },\n    setOpacity(opacity) {\n      leafletRef.value.setStyle({ opacity });\n    },\n    setLineCap(lineCap) {\n      leafletRef.value.setStyle({ lineCap });\n    },\n    setLineJoin(lineJoin) {\n      leafletRef.value.setStyle({ lineJoin });\n    },\n    setDashArray(dashArray) {\n      leafletRef.value.setStyle({ dashArray });\n    },\n    setDashOffset(dashOffset) {\n      leafletRef.value.setStyle({ dashOffset });\n    },\n    setFill(fill) {\n      leafletRef.value.setStyle({ fill });\n    },\n    setFillColor(fillColor) {\n      leafletRef.value.setStyle({ fillColor });\n    },\n    setFillOpacity(fillOpacity) {\n      leafletRef.value.setStyle({ fillOpacity });\n    },\n    setFillRule(fillRule) {\n      leafletRef.value.setStyle({ fillRule });\n    },\n    setClassName(className) {\n      leafletRef.value.setStyle({ className });\n    },\n  };\n\n  onBeforeUnmount(() => {\n    removeLayer({ leafletObject: leafletRef.value });\n  });\n\n  return { options, methods };\n};\n\nconst props$4 = {\n  ...props$3,\n  latLng: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  /**\n   * Radius of the marker in pixels.\n   */\n  radius: {\n    type: Number,\n    default: null,\n  },\n};\n\nconst setup$4 = (props, leafletRef, context) => {\n  const { options: pathOptions, methods: pathMethods } = setup$3(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...pathOptions,\n    ...props,\n  };\n  const methods = {\n    ...pathMethods,\n    setRadius(radius) {\n      leafletRef.value.setRadius(radius);\n    },\n    setLatLng(latLng) {\n      leafletRef.value.setLatLng(latLng);\n    },\n  };\n\n  return { options, methods };\n};\n\nconst props$5 = {\n  ...props$4,\n  /**\n   * Radius of the circle in meters.\n   */\n  radius: {\n    type: Number,\n    default: null,\n  },\n};\n\nconst setup$5 = (props, leafletRef, context) => {\n  const {\n    options: circleMarkerOptions,\n    methods: circleMarkerMethods,\n  } = setup$4(props, leafletRef, context);\n\n  const options = {\n    ...circleMarkerOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...circleMarkerMethods,\n  };\n\n  return { options, methods };\n};\n\n/**\n * Circle component, lets you add and personalize circles on the map\n */\nvar script = {\n  name: \"LCircle\",\n  props: props$5,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$5(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { circle, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = circle(props.latLng, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript.__file = \"src/components/LCircle.vue\";\n\n/**\n * Circle Marker component, lets you add and personalize circle markers on the map\n */\nvar script$1 = {\n  name: \"LCircleMarker\",\n  props: props$4,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$4(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { circleMarker, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = circleMarker(props.latLng, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$1.__file = \"src/components/LCircleMarker.vue\";\n\nconst props$6 = {\n  ...props,\n  position: {\n    type: String,\n    default: \"topright\",\n  },\n};\n\nconst setup$6 = (props, leafletRef) => {\n  const {\n    options: componentOptions,\n    methods: componentMethods,\n  } = setup(props);\n  const options = {\n    ...componentOptions,\n    position: props.position,\n  };\n\n  const methods = {\n    ...componentMethods,\n    setPosition(position) {\n      if (leafletRef.value) {\n        leafletRef.value.setPosition(position);\n      }\n    },\n  };\n\n  onUnmounted(() => {\n    if (leafletRef.value) {\n      leafletRef.value.remove();\n    }\n  });\n\n  return { options, methods };\n};\n\nconst render$1 = (slots) => {\n  if (slots.default) {\n    return h(\"div\", { ref: \"root\" }, slots.default());\n  }\n  return null;\n};\n\nvar script$2 = {\n  name: \"LControl\",\n  props: {\n    ...props$6,\n    disableClickPropagation: {\n      type: Boolean,\n      custom: true,\n      default: true,\n    },\n    disableScrollPropagation: {\n      type: Boolean,\n      custom: true,\n      default: false,\n    },\n  },\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setup$6(props, leafletRef);\n\n    onMounted(async () => {\n      const { Control, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      const LControl = Control.extend({\n        onAdd() {\n          return root.value;\n        },\n      });\n\n      leafletRef.value = new LControl(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n\n      if (props.disableClickPropagation) {\n        DomEvent.disableClickPropagation(root.value);\n      }\n      if (props.disableScrollPropagation) {\n        DomEvent.disableScrollPropagation(root.value);\n      }\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { root, leafletObject: leafletRef };\n  },\n  render() {\n    return render$1(this.$slots);\n  },\n};\n\nscript$2.__file = \"src/components/LControl.vue\";\n\nconst props$7 = {\n  ...props$6,\n  prefix: {\n    type: String,\n    default: \"Vue-Leaflet\",\n    custom: true,\n  },\n};\n\nconst setup$7 = (props, leafletRef) => {\n  const { options: controlOptions, methods: controlMethods } = setup$6(\n    props,\n    leafletRef\n  );\n  const options = {\n    ...controlOptions,\n    prefix: props.prefix,\n  };\n\n  const methods = {\n    ...controlMethods,\n    setPrefix(prefix) {\n      leafletRef.value.setPrefix(prefix);\n    },\n  };\n\n  return { options, methods };\n};\n\nvar script$3 = {\n  name: \"LControlAttribution\",\n  props: props$7,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setup$7(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = control.attribution(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$3.__file = \"src/components/LControlAttribution.vue\";\n\nconst props$8 = {\n  ...props$6,\n  collapsed: {\n    type: Boolean,\n    default: true,\n  },\n  autoZIndex: {\n    type: Boolean,\n    default: true,\n  },\n  hideSingleBase: {\n    type: Boolean,\n    default: false,\n  },\n  sortLayers: {\n    type: Boolean,\n    default: false,\n  },\n  sortFunction: {\n    type: Function,\n    default: undefined,\n  },\n};\n\nconst setup$8 = (props, leafletRef) => {\n  const { options: controlOptions } = setup$6(props, leafletRef);\n  const options = {\n    ...controlOptions,\n    collapsed: props.collapsed,\n    autoZIndex: props.autoZIndex,\n    hideSingleBase: props.hideSingleBase,\n    sortLayers: props.sortLayers,\n    sortFunction: props.sortFunction,\n  };\n\n  const methods = {\n    addLayer(layer) {\n      if (layer.layerType === \"base\") {\n        leafletRef.value.addBaseLayer(layer.leafletObject, layer.name);\n      } else if (layer.layerType === \"overlay\") {\n        leafletRef.value.addOverlay(layer.leafletObject, layer.name);\n      }\n    },\n    removeLayer(layer) {\n      leafletRef.value.removeLayer(layer.leafletObject);\n    },\n  };\n  return { options, methods };\n};\n\nvar script$4 = {\n  name: \"LControlLayers\",\n  props: props$8,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerLayerControl = inject(\"registerLayerControl\");\n\n    const { options, methods } = setup$8(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = control.layers(null, null, options);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      registerLayerControl({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$4.__file = \"src/components/LControlLayers.vue\";\n\nconst props$9 = {\n  ...props$6,\n  maxWidth: {\n    type: Number,\n    default: 100,\n  },\n  metric: {\n    type: Boolean,\n    default: true,\n  },\n  imperial: {\n    type: Boolean,\n    default: true,\n  },\n  updateWhenIdle: {\n    type: Boolean,\n    default: false,\n  },\n};\n\nconst setup$9 = (props, leafletRef) => {\n  const { options: controlOptions, methods: controlMethods } = setup$6(\n    props,\n    leafletRef\n  );\n  const options = {\n    ...controlOptions,\n    maxWidth: props.maxWidth,\n    metric: props.metric,\n    imperial: props.imperial,\n    updateWhenIdle: props.updateWhenIdle,\n  };\n\n  return { options, methods: controlMethods };\n};\n\nvar script$5 = {\n  name: \"LControlScale\",\n  props: props$9,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setup$9(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = control.scale(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$5.__file = \"src/components/LControlScale.vue\";\n\nconst props$a = {\n  ...props$6,\n  zoomInText: {\n    type: String,\n    default: \"+\",\n  },\n  zoomInTitle: {\n    type: String,\n    default: \"Zoom in\",\n  },\n  zoomOutText: {\n    type: String,\n    default: \"-\",\n  },\n  zoomOutTitle: {\n    type: String,\n    default: \"Zoom out\",\n  },\n};\n\nconst setup$a = (props, leafletRef) => {\n  const { options: controlOptions, methods: controlMethods } = setup$6(\n    props,\n    leafletRef\n  );\n  const options = {\n    ...controlOptions,\n    zoomInText: props.zoomInText,\n    zoomInTitle: props.zoomInTitle,\n    zoomOutText: props.zoomOutText,\n    zoomOutTitle: props.zoomOutTitle,\n  };\n\n  return { options, methods: controlMethods };\n};\n\nvar script$6 = {\n  name: \"LControlZoom\",\n  props: props$a,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const registerControl = inject(\"registerControl\");\n\n    const { options, methods } = setup$a(props, leafletRef);\n\n    onMounted(async () => {\n      const { control } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = control.zoom(options);\n      propsBinder(methods, leafletRef.value, props);\n      registerControl({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$6.__file = \"src/components/LControlZoom.vue\";\n\nconst props$b = {\n  ...props$1,\n};\n\nconst setup$b = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    props,\n    leafletRef,\n    context\n  );\n\n  const options = {\n    ...layerOptions,\n  };\n\n  const methods = {\n    ...layerMethods,\n    addLayer(layer) {\n      leafletRef.value.addLayer(layer.leafletObject);\n    },\n    removeLayer(layer) {\n      leafletRef.value.removeLayer(layer.leafletObject);\n    },\n  };\n\n  provide(\"addLayer\", methods.addLayer);\n  provide(\"removeLayer\", methods.removeLayer);\n\n  return { options, methods };\n};\n\nconst props$c = {\n  ...props$b,\n};\n\nconst setup$c = (props, leafletRef) => {\n  const { options: layerOptions, methods: layerGroupMethods } = setup$b(\n    props,\n    leafletRef\n  );\n\n  const options = {\n    ...layerOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...layerGroupMethods,\n  };\n\n  return { options, methods };\n};\n\nvar script$7 = {\n  props: props$c,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { methods, options } = setup$c(props, leafletRef);\n\n    onMounted(async () => {\n      const { featureGroup, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = featureGroup(options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$7.__file = \"src/components/LFeatureGroup.vue\";\n\nconst props$d = {\n  ...props$b,\n  geojson: {\n    type: [Object, Array],\n    default: () => ({}),\n  },\n};\n\nconst setup$d = (props, leafletRef) => {\n  const { options: layerOptions, methods: layerGroupMethods } = setup$b(\n    props,\n    leafletRef\n  );\n\n  const options = {\n    ...layerOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...layerGroupMethods,\n    setGeojson(newVal) {\n      leafletRef.value.clearLayers();\n      leafletRef.value.addData(newVal);\n    },\n    getGeoJSONData() {\n      return leafletRef.value.toGeoJSON();\n    },\n    getBounds() {\n      return leafletRef.value.getBounds();\n    },\n  };\n\n  return { options, methods };\n};\n\nvar script$8 = {\n  props: props$d,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { methods, options } = setup$d(props, leafletRef);\n\n    onMounted(async () => {\n      const { geoJSON, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = geoJSON(props.geojson, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$8.__file = \"src/components/LGeoJson.vue\";\n\nconst props$e = {\n  ...props$1,\n  pane: {\n    type: String,\n    default: \"tilePane\",\n  },\n  opacity: {\n    type: Number,\n    custom: false,\n    default: 1.0,\n  },\n  zIndex: {\n    type: Number,\n    default: 1,\n  },\n  tileSize: {\n    type: Number,\n    default: 256,\n  },\n  noWrap: {\n    type: Boolean,\n    default: false,\n  },\n  minZoom: {\n    type: Number,\n    default: 0,\n  },\n  maxZoom: {\n    type: Number,\n    default: undefined,\n  },\n};\n\nconst setup$e = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...layerOptions,\n    pane: props.pane,\n    opacity: props.opacity,\n    zIndex: props.zIndex,\n    tileSize: props.tileSize,\n    noWrap: props.noWrap,\n    minZoom: props.minZoom,\n    maxZoom: props.maxZoom,\n  };\n  return { options, methods: { ...layerMethods } };\n};\n\nvar script$9 = {\n  props: {\n    ...props$e,\n    childRender: {\n      type: Function,\n      required: true,\n    },\n  },\n  setup(props, context) {\n    const leafletRef = ref({});\n    const tileComponents = ref({});\n    const root = ref(null);\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$e(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { GridLayer, DomEvent, DomUtil } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      methods.onUnload = (e) => {\n        const key = leafletRef.value._tileCoordsToKey(e.coords);\n        if (tileComponents[key]) {\n          tileComponents[key].innerHTML = \"\";\n          tileComponents[key] = undefined;\n        }\n      };\n\n      methods.setTileComponent = () => {\n        leafletRef.value.redraw();\n      };\n\n      const GLayer = GridLayer.extend({\n        createTile(coords) {\n          const key = leafletRef.value._tileCoordsToKey(coords);\n          tileComponents[key] = DomUtil.create(\"div\");\n\n          let vNode = h(\n            { setup: props.childRender, props: [\"coords\"] },\n            { coords }\n          );\n          render$3(vNode, tileComponents[key]);\n\n          return tileComponents[key];\n        },\n      });\n\n      leafletRef.value = new GLayer(options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      leafletRef.value.on(\"tileunload\", methods.onUnload);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    onUnmounted(() => {\n      leafletRef.value.off(\"tileunload\", methods.unLoad);\n    });\n\n    return { root, ready, leafletObject: leafletRef };\n  },\n  render() {\n    if (this.ready) {\n      return h(\"div\", { style: { display: \"none\" }, ref: \"root\" });\n    }\n    return null;\n  },\n};\n\nscript$9.__file = \"src/components/LGridLayer.vue\";\n\nconst props$f = {\n  iconUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  iconRetinaUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  iconSize: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  iconAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  popupAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: () => [0, 0],\n  },\n  tooltipAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: () => [0, 0],\n  },\n  shadowUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  shadowRetinaUrl: {\n    type: String,\n    custom: true,\n    default: null,\n  },\n  shadowSize: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  shadowAnchor: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  bgPos: {\n    type: [Object, Array],\n    custom: true,\n    default: () => [0, 0],\n  },\n  className: {\n    type: String,\n    custom: true,\n    default: \"\",\n  },\n  options: {\n    type: Object,\n    custom: true,\n    default: () => ({}),\n  },\n};\n\n/**\n * Icon component, lets you add and custom icons to the map\n */\nvar script$a = {\n  name: \"LIcon\",\n  props: {\n    ...props$f,\n    ...props,\n  },\n  setup(props, context) {\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const canSetParentHtml = inject(\"canSetParentHtml\");\n    const setParentHtml = inject(\"setParentHtml\");\n    const setIcon = inject(\"setIcon\");\n\n    let onDomEvent;\n    let offDomEvent;\n    let divIcon;\n    let icon;\n    let iconObject = undefined;\n\n    const createIcon = (el, recreationNeeded, htmlSwapNeeded) => {\n      const elHtml = el && el.innerHTML;\n      if (!recreationNeeded) {\n        if (htmlSwapNeeded && iconObject && canSetParentHtml()) {\n          setParentHtml(elHtml);\n        }\n        return;\n      }\n\n      const listeners = remapEvents(context.attrs);\n      if (iconObject) {\n        offDomEvent(iconObject, listeners);\n      }\n\n      const { options: componentOptions } = setup(props);\n      const options = {\n        ...componentOptions,\n        iconUrl: props.iconUrl,\n        iconRetinaUrl: props.iconRetinaUrl,\n        iconSize: props.iconSize,\n        iconAnchor: props.iconAnchor,\n        popupAnchor: props.popupAnchor,\n        tooltipAnchor: props.tooltipAnchor,\n        shadowUrl: props.shadowUrl,\n        shadowRetinaUrl: props.shadowRetinaUrl,\n        shadowSize: props.shadowSize,\n        shadowAnchor: props.shadowAnchor,\n        bgPos: props.bgPos,\n        className: props.className,\n        html: elHtml || props.html,\n      };\n\n      iconObject = options.html ? divIcon(options) : icon(options);\n      onDomEvent(iconObject, listeners);\n      setIcon(iconObject);\n    };\n\n    const scheduleCreateIcon = () => {\n      nextTick(() => createIcon(root.value, true, false));\n    };\n\n    const scheduleHtmlSwap = () => {\n      nextTick(() => createIcon(root.value, false, true));\n    };\n\n    const methods = {\n      setIconUrl: scheduleCreateIcon,\n      setIconRetinaUrl: scheduleCreateIcon,\n      setIconSize: scheduleCreateIcon,\n      setIconAnchor: scheduleCreateIcon,\n      setPopupAnchor: scheduleCreateIcon,\n      setTooltipAnchor: scheduleCreateIcon,\n      setShadowUrl: scheduleCreateIcon,\n      setShadowRetinaUrl: scheduleCreateIcon,\n      setShadowAnchor: scheduleCreateIcon,\n      setBgPos: scheduleCreateIcon,\n      setClassName: scheduleCreateIcon,\n      setHtml: scheduleCreateIcon,\n    };\n\n    onMounted(async () => {\n      const { DomEvent, divIcon: lDivIcon, icon: lIcon } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      onDomEvent = DomEvent.on;\n      offDomEvent = DomEvent.off;\n      divIcon = lDivIcon;\n      icon = lIcon;\n\n      propsBinder(methods, {}, props);\n\n      const observer = new MutationObserver(scheduleHtmlSwap);\n      observer.observe(root.value, {\n        attributes: true,\n        childList: true,\n        characterData: true,\n        subtree: true,\n      });\n      scheduleCreateIcon();\n    });\n\n    return { root };\n  },\n  render() {\n    const content = this.$slots.default ? this.$slots.default() : undefined;\n    return h(\"div\", { ref: \"root\" }, content);\n  },\n};\n\nscript$a.__file = \"src/components/LIcon.vue\";\n\n/**\n * @typedef {import('leaflet/dist/leaflet-src.esm.js').LatLngBounds} LatLngBounds\n */\n\nconst props$g = {\n  ...props$1,\n  url: {\n    type: String,\n    required: true,\n  },\n  bounds: {\n    type: [Array, Object],\n    required: true,\n  },\n  opacity: {\n    type: Number,\n    custom: true,\n    default: 1.0,\n  },\n  alt: {\n    type: String,\n    default: \"\",\n  },\n  interactive: {\n    type: Boolean,\n    default: false,\n  },\n  crossOrigin: {\n    type: Boolean,\n    default: false,\n  },\n  errorOverlayUrl: {\n    type: String,\n    custom: true,\n    default: \"\",\n  },\n  zIndex: {\n    type: Number,\n    custom: true,\n    default: 1,\n  },\n  className: {\n    type: String,\n    default: \"\",\n  },\n};\n\nconst setup$f = (setupProps, LeafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    setupProps,\n    LeafletRef,\n    context\n  );\n  const options = {\n    ...layerOptions,\n    ...setupProps,\n  };\n\n  const methods = {\n    ...layerMethods,\n    /**\n     * Sets the opacity of the overlay.\n     * @param {number} opacity\n     */\n    setOpacity(opacity) {\n      return LeafletRef.value.setOpacity(opacity);\n    },\n    /**\n     * Changes the URL of the image.\n     * @param {string} url\n     */\n    setUrl(url) {\n      return LeafletRef.value.setUrl(url);\n    },\n    /**\n     * Update the bounds that this ImageOverlay covers\n     * @param {LatLngBounds | Array<Array<number>>} bounds\n     */\n    setBounds(bounds) {\n      return LeafletRef.value.setBounds(bounds);\n    },\n    /**\n     * Get the bounds that this ImageOverlay covers\n     * @returns {LatLngBounds}\n     */\n    getBounds() {\n      return LeafletRef.value.getBounds();\n    },\n    /**\n     * Returns the instance of HTMLImageElement used by this overlay.\n     * @returns {HTMLElement}\n     */\n    getElement() {\n      return LeafletRef.value.getElement();\n    },\n    /**\n     * Brings the layer to the top of all overlays.\n     */\n    bringToFront() {\n      return LeafletRef.value.bringToFront();\n    },\n    /**\n     * Brings the layer to the bottom of all overlays.\n     */\n    bringToBack() {\n      return LeafletRef.value.bringToBack();\n    },\n    /**\n     * Changes the zIndex of the image overlay.\n     * @param {number} zIndex\n     */\n    setZIndex(zIndex) {\n      return LeafletRef.value.setZIndex(zIndex);\n    },\n  };\n\n  return { options, methods };\n};\n\n/**\n * ImageOverlay component, render a plain image instead of a geospatial map.\n */\nvar script$b = {\n  name: \"LImageOverlay\",\n  props: props$g,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$f(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { imageOverlay, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = imageOverlay(props.url, props.bounds, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$b.__file = \"src/components/LImageOverlay.vue\";\n\nvar script$c = {\n  props: props$b,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { methods } = setup$b(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { layerGroup, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = layerGroup(props.options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$c.__file = \"src/components/LLayerGroup.vue\";\n\nvar script$d = {\n  emits: [\"ready\", \"update:zoom\", \"update:center\", \"update:bounds\"],\n  props: {\n    ...props,\n    /**\n     * The center of the map, supports .sync modifier\n     */\n    center: {\n      type: [Object, Array],\n      default: () => [0, 0],\n    },\n    /**\n     * The bounds of the map, supports .sync modifier\n     */\n    bounds: {\n      type: [Array, Object],\n      default: undefined,\n    },\n    /**\n     * The max bounds of the map\n     */\n    maxBounds: {\n      type: [Array, Object],\n      default: undefined,\n    },\n    /**\n     * The zoom of the map, supports .sync modifier\n     */\n    zoom: {\n      type: Number,\n      default: 0,\n    },\n    /**\n     * The minZoom of the map\n     */\n    minZoom: {\n      type: Number,\n      default: undefined,\n    },\n    /**\n     * The maxZoom of the map\n     */\n    maxZoom: {\n      type: Number,\n      default: undefined,\n    },\n    /**\n     * The paddingBottomRight of the map\n     */\n    paddingBottomRight: {\n      type: Array,\n      default: undefined,\n    },\n    /**\n     * The paddingTopLeft of the map\n     */\n    paddingTopLeft: {\n      type: Array,\n      default: undefined,\n    },\n    /**\n     * The padding of the map\n     */\n    padding: {\n      type: Array,\n      default: undefined,\n    },\n    /**\n     * The worldCopyJump option for the map\n     */\n    worldCopyJump: {\n      type: Boolean,\n      default: false,\n    },\n    /**\n     * The CRS to use for the map. Can be an object that defines a coordinate reference\n     * system for projecting geographical points into screen coordinates and back\n     * (see https://leafletjs.com/reference-1.7.1.html#crs-l-crs-base), or a string\n     * name identifying one of Leaflet's defined CRSs, such as \"EPSG4326\".\n     */\n    crs: {\n      type: [String, Object],\n      default: \"EPSG3857\",\n    },\n    maxBoundsViscosity: {\n      type: Number,\n      default: undefined,\n    },\n    inertia: {\n      type: Boolean,\n      default: undefined,\n    },\n    inertiaDeceleration: {\n      type: Number,\n      default: undefined,\n    },\n    inertiaMaxSpeed: {\n      type: Number,\n      default: undefined,\n    },\n    easeLinearity: {\n      type: Number,\n      default: undefined,\n    },\n    zoomAnimation: {\n      type: Boolean,\n      default: undefined,\n    },\n    zoomAnimationThreshold: {\n      type: Number,\n      default: undefined,\n    },\n    fadeAnimation: {\n      type: Boolean,\n      default: undefined,\n    },\n    markerZoomAnimation: {\n      type: Boolean,\n      default: undefined,\n    },\n    noBlockingAnimations: {\n      type: Boolean,\n      default: false,\n    },\n    useGlobalLeaflet: {\n      type: Boolean,\n      default: false,\n    },\n  },\n  setup(props, context) {\n    const root = ref(null);\n    const blueprint = reactive({\n      ready: false,\n      leafletRef: {},\n      layersToAdd: [],\n      layersInControl: [],\n    });\n    const { options: componentOptions } = setup(props);\n    const options = {\n      ...componentOptions,\n      minZoom: props.minZoom,\n      maxZoom: props.maxZoom,\n      maxBounds: props.maxBounds,\n      maxBoundsViscosity: props.maxBoundsViscosity,\n      worldCopyJump: props.worldCopyJump,\n      crs: props.crs,\n      center: props.center,\n      zoom: props.zoom,\n      inertia: props.inertia,\n      inertiaDeceleration: props.inertiaDeceleration,\n      inertiaMaxSpeed: props.inertiaMaxSpeed,\n      easeLinearity: props.easeLinearity,\n      zoomAnimation: props.zoomAnimation,\n      zoomAnimationThreshold: props.zoomAnimationThreshold,\n      fadeAnimation: props.fadeAnimation,\n      markerZoomAnimation: props.markerZoomAnimation,\n    };\n\n    const addLayer = provideLeafletWrapper(\"addLayer\");\n    const removeLayer = provideLeafletWrapper(\"removeLayer\");\n    const registerControl = provideLeafletWrapper(\"registerControl\");\n    const registerLayerControl = provideLeafletWrapper(\"registerLayerControl\");\n    provide(GLOBAL_LEAFLET_OPT, props.useGlobalLeaflet);\n\n    const eventHandlers = {\n      moveEndHandler() {\n        /**\n         * Triggers when zoom is updated\n         * @type {number,string}\n         */\n        context.emit(\"update:zoom\", blueprint.leafletRef.getZoom());\n        /**\n         * Triggers when center is updated\n         * @type {object,array}\n         */\n        context.emit(\"update:center\", blueprint.leafletRef.getCenter());\n\n        /**\n         * Triggers when bounds are updated\n         * @type {object}\n         */\n        context.emit(\"update:bounds\", blueprint.leafletRef.getBounds());\n      },\n      overlayAddHandler(e) {\n        const layer = blueprint.layersInControl.find((l) => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(true);\n        }\n      },\n      overlayRemoveHandler(e) {\n        const layer = blueprint.layersInControl.find((l) => l.name === e.name);\n        if (layer) {\n          layer.updateVisibleProp(false);\n        }\n      },\n    };\n\n    onMounted(async () => {\n      if (props.useGlobalLeaflet) {\n        WINDOW_OR_GLOBAL.L = WINDOW_OR_GLOBAL.L || (await import('leaflet'));\n      }\n      const {\n        map,\n        CRS,\n        Icon,\n        latLngBounds,\n        latLng,\n        DomEvent,\n      } = props.useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      try {\n        options.beforeMapMount && (await options.beforeMapMount());\n      } catch (error) {\n        console.error(\n          `The following error occurred running the provided beforeMapMount hook ${error.message}`\n        );\n      }\n\n      await resetWebpackIcon(Icon);\n\n      const optionsCrs =\n        typeof options.crs == \"string\" ? CRS[options.crs] : options.crs;\n      options.crs = optionsCrs || CRS.EPSG3857;\n\n      const methods = {\n        addLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd.push(layer);\n            } else {\n              const exist = blueprint.layersInControl.find(\n                (l) =>\n                  l.leafletObject._leaflet_id ===\n                  layer.leafletObject._leaflet_id\n              );\n              if (!exist) {\n                blueprint.layerControl.addLayer(layer);\n                blueprint.layersInControl.push(layer);\n              }\n            }\n          }\n          if (layer.visible !== false) {\n            blueprint.leafletRef.addLayer(layer.leafletObject);\n          }\n        },\n        removeLayer(layer) {\n          if (layer.layerType !== undefined) {\n            if (blueprint.layerControl === undefined) {\n              blueprint.layersToAdd = blueprint.layersToAdd.filter(\n                (l) => l.name !== layer.name\n              );\n            } else {\n              blueprint.layerControl.removeLayer(layer.leafletObject);\n              blueprint.layersInControl = blueprint.layersInControl.filter(\n                (l) =>\n                  l.leafletObject._leaflet_id !==\n                  layer.leafletObject._leaflet_id\n              );\n            }\n          }\n          blueprint.leafletRef.removeLayer(layer.leafletObject);\n        },\n\n        registerLayerControl(lControlLayer) {\n          blueprint.layerControl = lControlLayer;\n          blueprint.layersToAdd.forEach((layer) => {\n            blueprint.layerControl.addLayer(layer);\n          });\n          blueprint.layersToAdd = [];\n\n          registerControl(lControlLayer);\n        },\n\n        registerControl(lControl) {\n          blueprint.leafletRef.addControl(lControl.leafletObject);\n        },\n\n        setZoom(newVal) {\n          const zoom = blueprint.leafletRef.getZoom();\n          if (newVal !== zoom) {\n            blueprint.leafletRef.setZoom(newVal, {\n              animate: props.noBlockingAnimations ? false : null,\n            });\n          }\n        },\n\n        setPaddingBottomRight(newVal) {\n          blueprint.paddingBottomRight = newVal;\n        },\n        setPaddingTopLeft(newVal) {\n          blueprint.paddingTopLeft = newVal;\n        },\n        setPadding(newVal) {\n          blueprint.padding = newVal;\n        },\n        setCrs(newVal) {\n          const prevBounds = blueprint.leafletRef.getBounds();\n          blueprint.leafletRef.options.crs = newVal;\n          blueprint.leafletRef.fitBounds(prevBounds, {\n            animate: false,\n            padding: [0, 0],\n          });\n        },\n        fitBounds(bounds) {\n          blueprint.leafletRef.fitBounds(bounds, {\n            animate: this.noBlockingAnimations ? false : null,\n          });\n        },\n        setBounds(newVal) {\n          if (!newVal) {\n            return;\n          }\n          const newBounds = latLngBounds(newVal);\n          if (!newBounds.isValid()) {\n            return;\n          }\n          const oldBounds =\n            blueprint.lastSetBounds || blueprint.leafletRef.getBounds();\n          const boundsChanged = !oldBounds.equals(newBounds, 0); // set maxMargin to 0 - check exact equals\n          if (boundsChanged) {\n            blueprint.lastSetBounds = newBounds;\n            blueprint.leafletRef.fitBounds(newBounds, this.fitBoundsOptions);\n          }\n        },\n\n        setCenter(newVal) {\n          if (newVal == null) {\n            return;\n          }\n          const newCenter = latLng(newVal);\n          const oldCenter =\n            blueprint.lastSetCenter || blueprint.leafletRef.getCenter();\n          if (\n            oldCenter.lat !== newCenter.lat ||\n            oldCenter.lng !== newCenter.lng\n          ) {\n            blueprint.lastSetCenter = newCenter;\n            blueprint.leafletRef.panTo(newCenter, {\n              animate: this.noBlockingAnimations ? false : null,\n            });\n          }\n        },\n      };\n\n      updateLeafletWrapper(addLayer, methods.addLayer);\n      updateLeafletWrapper(removeLayer, methods.removeLayer);\n      updateLeafletWrapper(registerControl, methods.registerControl);\n      updateLeafletWrapper(registerLayerControl, methods.registerLayerControl);\n\n      blueprint.leafletRef = map(root.value, options);\n\n      propsBinder(methods, blueprint.leafletRef, props);\n      const listeners = remapEvents(context.attrs);\n\n      blueprint.leafletRef.on(\n        \"moveend\",\n        debounce(eventHandlers.moveEndHandler, 100)\n      );\n      blueprint.leafletRef.on(\"overlayadd\", eventHandlers.overlayAddHandler);\n      blueprint.leafletRef.on(\n        \"overlayremove\",\n        eventHandlers.overlayRemoveHandler\n      );\n      DomEvent.on(blueprint.leafletRef, listeners);\n      blueprint.ready = true;\n      nextTick(() => context.emit(\"ready\", blueprint.leafletRef));\n    });\n\n    onBeforeUnmount(() => {\n      if (blueprint.leafletRef) {\n        blueprint.leafletRef.remove();\n      }\n    });\n\n    const leafletObject = computed(() => blueprint.leafletRef);\n    const ready = computed(() => blueprint.ready);\n    return { root, ready, leafletObject };\n  },\n  render() {\n    return h(\n      \"div\",\n      { style: { width: \"100%\", height: \"100%\" }, ref: \"root\" },\n      this.ready ? this.$slots.default() : {}\n    );\n  },\n};\n\nscript$d.__file = \"src/components/LMap.vue\";\n\nconst props$h = {\n  ...props$1,\n  pane: {\n    type: String,\n    default: \"markerPane\",\n  },\n  draggable: {\n    type: Boolean,\n    custom: true,\n    default: false,\n  },\n  latLng: {\n    type: [Object, Array],\n    custom: true,\n    default: null,\n  },\n  icon: {\n    type: [Object],\n    default: () => undefined,\n    custom: false,\n  },\n  zIndexOffset: {\n    type: Number,\n    custom: false,\n    default: null,\n  },\n};\n\nconst setup$g = (props, leafletRef, context) => {\n  const { options: layerOptions, methods: layerMethods } = setup$1(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...layerOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...layerMethods,\n    setDraggable(value) {\n      if (leafletRef.value.dragging) {\n        value\n          ? leafletRef.value.dragging.enable()\n          : leafletRef.value.dragging.disable();\n      }\n    },\n    latLngSync(event) {\n      context.emit(\"update:latLng\", event.latlng);\n      context.emit(\"update:lat-lng\", event.latlng);\n    },\n    setLatLng(newVal) {\n      if (newVal == null) {\n        return;\n      }\n\n      if (leafletRef.value) {\n        const oldLatLng = leafletRef.value.getLatLng();\n        if (!oldLatLng || !oldLatLng.equals(newVal)) {\n          leafletRef.value.setLatLng(newVal);\n        }\n      }\n    },\n  };\n  return { options, methods };\n};\n\n/**\n * Marker component, lets you add and personalize markers on the map\n */\nvar script$e = {\n  name: \"LMarker\",\n  props: props$h,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    provide(\"canSetParentHtml\", () => !!leafletRef.value.getElement());\n    provide(\n      \"setParentHtml\",\n      (html) => (leafletRef.value.getElement().innerHTML = html)\n    );\n    provide(\n      \"setIcon\",\n      (newIcon) => leafletRef.value.setIcon && leafletRef.value.setIcon(newIcon)\n    );\n    const { options, methods } = setup$g(props, leafletRef, context);\n    if (options.icon === undefined) {\n      // If the options objection has a property named 'icon', then Leaflet will overwrite\n      // the default icon with it for the marker, _even if it is undefined_.\n      // This leads to the issue discussed in https://github.com/vue-leaflet/vue-leaflet/issues/130\n      delete options.icon;\n    }\n\n    onMounted(async () => {\n      const { marker, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = marker(props.latLng, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      leafletRef.value.on(\"move\", debounce(methods.latLngSync, 100));\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$e.__file = \"src/components/LMarker.vue\";\n\nconst props$i = {\n  ...props$3,\n  latLngs: {\n    type: Array,\n    default: () => [],\n  },\n  smoothFactor: {\n    type: Number,\n    custom: true,\n    default: 1.0,\n  },\n  noClip: {\n    type: Boolean,\n    custom: true,\n    default: false,\n  },\n};\n\nconst setup$h = (props, leafletRef, context) => {\n  const { options: pathOptions, methods: pathMethods } = setup$3(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...pathOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...pathMethods,\n    setSmoothFactor(smoothFactor) {\n      leafletRef.value.setStyle({ smoothFactor });\n    },\n    setNoClip(noClip) {\n      leafletRef.value.setStyle({ noClip });\n    },\n    addLatLng(latLng) {\n      leafletRef.value.addLatLng(latLng);\n    },\n  };\n  return { options, methods };\n};\n\nconst props$j = {\n  ...props$i,\n};\n\nconst setup$i = (props, leafletRef, context) => {\n  const { options: polylineOptions, methods: polylineMethods } = setup$h(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...polylineOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...polylineMethods,\n    toGeoJSON(precision) {\n      return leafletRef.value.toGeoJSON(precision);\n    },\n  };\n\n  return { options, methods };\n};\n\n/**\n * Polygon component, lets you add and customize polygon regions on the map\n */\nvar script$f = {\n  name: \"LPolygon\",\n  props: props$j,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$i(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { polygon, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = polygon(props.latLngs, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$f.__file = \"src/components/LPolygon.vue\";\n\n/**\n * Polyline component, lets you add and personalize polylines on the map\n */\nvar script$g = {\n  name: \"LPolyline\",\n  props: props$i,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$h(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { polyline, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = polyline(props.latLngs, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$g.__file = \"src/components/LPolyline.vue\";\n\nconst props$k = {\n  ...props,\n  content: {\n    type: String,\n    default: null,\n  },\n};\n\nconst setup$j = (props, leafletRef) => {\n  const { options, methods: componentMethods } = setup(props);\n  const methods = {\n    ...componentMethods,\n    setContent(newVal) {\n      if (leafletRef.value && newVal !== null && newVal !== undefined) {\n        leafletRef.value.setContent(newVal);\n      }\n    },\n  };\n  return { options, methods };\n};\n\nconst render$2 = (slots) => {\n  if (slots.default) {\n    return h(\"div\", { ref: \"root\" }, slots.default());\n  }\n  return null;\n};\n\nconst props$l = {\n  ...props$k,\n  latLng: {\n    type: [Object, Array],\n    default: () => [],\n  },\n};\n\nconst setup$k = (props, leafletRef) => {\n  const { options, methods } = setup$j(props, leafletRef);\n  const unbindPopup = inject(\"unbindPopup\");\n\n  onBeforeUnmount(() => {\n    unbindPopup();\n  });\n\n  return { options, methods };\n};\n\n/**\n * Display a popup on the map\n */\nvar script$h = {\n  name: \"LPopup\",\n  props: props$l,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const bindPopup = inject(\"bindPopup\");\n\n    const { options, methods } = setup$k(props, leafletRef);\n\n    onMounted(async () => {\n      const { popup, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = popup(options);\n\n      if (props.latLng !== undefined) {\n        leafletRef.value.setLatLng(props.latLng);\n      }\n\n      propsBinder(methods, leafletRef.value, props);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      leafletRef.value.setContent(props.content || root.value);\n      bindPopup({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { root, leafletObject: leafletRef };\n  },\n  render() {\n    return render$2(this.$slots);\n  },\n};\n\nscript$h.__file = \"src/components/LPopup.vue\";\n\nconst props$m = {\n  ...props$j,\n  bounds: {\n    type: Array,\n    default: undefined,\n  },\n};\n\nconst setup$l = (props, leafletRef, context) => {\n  const { options: polygonOptions, methods: polygonMethods } = setup$i(\n    props,\n    leafletRef,\n    context\n  );\n  const options = {\n    ...polygonOptions,\n    ...props,\n  };\n\n  const methods = {\n    ...polygonMethods,\n    setBounds(latLngBounds) {\n      leafletRef.value.setBounds(latLngBounds);\n    },\n    setLatLngs(latLngs) {\n      // Calling setLatLngs on a Leaflet rectangle will convert it\n      // to a polygon. So instead, we call setBounds here to ensure\n      // that the rectangle remains a rectangle, defined by the\n      // bounds of the points in the latLngs array.\n      leafletRef.value.setBounds(latLngs);\n    },\n  };\n\n  return { options, methods };\n};\n\n/**\n * Rectangle component, lets you add and customize rectangular regions on the map\n */\nvar script$i = {\n  name: \"LRectangle\",\n  props: props$m,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const ready = ref(false);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$l(props, leafletRef, context);\n\n    onMounted(async () => {\n      const { rectangle, latLngBounds, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      const bounds =\n        props.bounds && props.bounds.length\n          ? latLngBounds(props.bounds)\n          : latLngBounds(props.latLngs);\n      leafletRef.value = rectangle(bounds, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      ready.value = true;\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { ready, leafletObject: leafletRef };\n  },\n  render() {\n    return render(this.ready, this.$slots);\n  },\n};\n\nscript$i.__file = \"src/components/LRectangle.vue\";\n\nconst props$n = {\n  ...props$e,\n  tms: {\n    type: Boolean,\n    default: false,\n  },\n  subdomains: {\n    type: String,\n    default: \"abc\",\n  },\n  detectRetina: {\n    type: Boolean,\n    default: false,\n  },\n  url: {\n    type: String,\n    default: null,\n  },\n};\n\nconst setup$m = (props, leafletRef) => {\n  const {\n    options: gridLayerOptions,\n    methods: gridLayerMethods,\n  } = setup$e(props, leafletRef);\n  const options = {\n    ...gridLayerOptions,\n    tms: props.tms,\n    subdomains: props.subdomains,\n    detectRetina: props.detectRetina,\n  };\n  return {\n    options,\n    methods: {\n      ...gridLayerMethods,\n    },\n  };\n};\n\nvar script$j = {\n  props: props$n,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$m(props, leafletRef);\n\n    onMounted(async () => {\n      const { tileLayer, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n      leafletRef.value = tileLayer(props.url, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n\n    return { leafletObject: leafletRef };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$j.__file = \"src/components/LTileLayer.vue\";\n\nconst props$o = {\n  ...props$k,\n};\n\nconst setup$n = (props, leafletRef) => {\n  const { options, methods } = setup$j(props, leafletRef);\n  const unbindTooltip = inject(\"unbindTooltip\");\n\n  onBeforeUnmount(() => {\n    unbindTooltip();\n  });\n\n  return { options, methods };\n};\n\n/**\n * Display a tooltip on the map\n */\nvar script$k = {\n  name: \"LTooltip\",\n  props: props$o,\n  setup(props, context) {\n    const leafletRef = ref({});\n    const root = ref(null);\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const bindTooltip = inject(\"bindTooltip\");\n\n    const { options, methods } = setup$n(props, leafletRef);\n\n    onMounted(async () => {\n      const { tooltip, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = tooltip(options);\n\n      propsBinder(methods, leafletRef.value, props);\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n      leafletRef.value.setContent(props.content || root.value);\n      bindTooltip({ leafletObject: leafletRef.value });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { root, leafletObject: leafletRef };\n  },\n  render() {\n    return render$2(this.$slots);\n  },\n};\n\nscript$k.__file = \"src/components/LTooltip.vue\";\n\nconst props$p = {\n  ...props$n,\n  baseUrl: {\n    type: String,\n    default: null,\n    required: true,\n  },\n  layers: {\n    type: String,\n    default: \"\",\n  },\n  styles: {\n    type: String,\n    default: \"\",\n  },\n  format: {\n    type: String,\n    default: \"image/jpeg\",\n  },\n  transparent: {\n    type: Boolean,\n    custom: false,\n  },\n  version: {\n    type: String,\n    default: \"1.1.1\",\n  },\n  crs: {\n    default: null,\n  },\n  upperCase: {\n    type: Boolean,\n    default: false,\n  },\n};\n\nconst setup$o = (props, leafletRef) => {\n  const {\n    options: tileLayerOptions,\n    methods: tileLayerMethods,\n  } = setup$m(props, leafletRef);\n  const options = {\n    ...tileLayerOptions,\n    layers: props.layers,\n    styles: props.styles,\n    format: props.format,\n    transparent: props.transparent,\n    version: props.version,\n    crs: props.crs,\n    upperCase: props.upperCase,\n  };\n  return {\n    options,\n    methods: {\n      ...tileLayerMethods,\n    },\n  };\n};\n\nvar script$l = {\n  props: props$p,\n  setup(props, context) {\n    const leafletRef = ref({});\n\n    const useGlobalLeaflet = inject(GLOBAL_LEAFLET_OPT);\n    const addLayer = inject(\"addLayer\");\n\n    const { options, methods } = setup$o(props, leafletRef);\n\n    onMounted(async () => {\n      const { tileLayer, DomEvent } = useGlobalLeaflet\n        ? WINDOW_OR_GLOBAL.L\n        : await import('leaflet/dist/leaflet-src.esm');\n\n      leafletRef.value = tileLayer.wms(props.baseUrl, options);\n\n      const listeners = remapEvents(context.attrs);\n      DomEvent.on(leafletRef.value, listeners);\n\n      propsBinder(methods, leafletRef.value, props);\n      addLayer({\n        ...props,\n        ...methods,\n        leafletObject: leafletRef.value,\n      });\n      nextTick(() => context.emit(\"ready\", leafletRef.value));\n    });\n    return { leafletObject: leafletRef.value };\n  },\n  render() {\n    return null;\n  },\n};\n\nscript$l.__file = \"src/components/LWmsTileLayer.vue\";\n\nexport { script as LCircle, script$1 as LCircleMarker, script$2 as LControl, script$3 as LControlAttribution, script$4 as LControlLayers, script$5 as LControlScale, script$6 as LControlZoom, script$7 as LFeatureGroup, script$8 as LGeoJson, script$9 as LGridLayer, script$a as LIcon, script$b as LImageOverlay, script$c as LLayerGroup, script$d as LMap, script$e as LMarker, script$f as LPolygon, script$g as LPolyline, script$h as LPopup, script$i as LRectangle, script$j as LTileLayer, script$k as LTooltip, script$l as LWmsTileLayer };\n//# sourceMappingURL=vue-leaflet.esm.js.map\n","export * from \"-!../../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--9-oneOf-1-0!../../../node_modules/css-loader/dist/cjs.js??ref--9-oneOf-1-1!../../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../../node_modules/postcss-loader/src/index.js??ref--9-oneOf-1-2!../../../node_modules/sass-loader/dist/cjs.js??ref--9-oneOf-1-3!../../../node_modules/cache-loader/dist/cjs.js??ref--1-0!../../../node_modules/vue-loader-v16/dist/index.js??ref--1-1!./Map.vue?vue&type=style&index=0&id=d027c380&lang=scss&scoped=true\"","<template>\r\n  <div class=\"container\" id=\"contacts\">\r\n    <h1>Contact Us</h1>\r\n    <div>      \r\n      <div>\r\n        <FeedbackForm/>\r\n      </div>\r\n\r\n      <div>\r\n        <Map :center=\"[47.41322, -1.219482]\"/>        \r\n      </div>\r\n    </div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport Map from '../components/parts/Map.vue'\r\nimport FeedbackForm from '../components/parts/FeedbackForm.vue'\r\n\r\n\r\nexport default {\r\n  name:\"Contact\",\r\n  components:{\r\n    Map,\r\n    FeedbackForm\r\n  }\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n#contacts{\r\n  padding: 150px 0;  \r\n  \r\n  h1{\r\n    font-family: \"Hind Madurai\";\r\n    font-weight: 700;\r\n    font-size: 3.5625rem;\r\n    line-height: 69px;\r\n    text-align: center;\r\n    margin-bottom: 50px;\r\n    }\r\n}\r\n\r\n</style>","<template>\r\n    <div id=\"map\">\r\n        <l-map\r\n            v-model=\"zoom\"\r\n            v-model:zoom=\"zoom\"\r\n            :center=\"center\"\r\n            @move=\"log('move')\"\r\n            >\r\n            <l-tile-layer\r\n                url=\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\"\r\n            ></l-tile-layer>\r\n            <l-control-layers />\r\n            <l-marker :lat-lng=\"center\">\r\n                <l-tooltip>\r\n                I am here\r\n                </l-tooltip>\r\n            </l-marker>\r\n        </l-map>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport \"leaflet/dist/leaflet.css\"\r\nimport { \r\n    LMap, \r\n    LTileLayer,\r\n    LMarker,\r\n    LControlLayers,\r\n    LTooltip } from \"@vue-leaflet/vue-leaflet\";\r\n\r\nexport default {\r\n    name:\"Map\",\r\n    props:['center'],\r\n    components: {\r\n    LMap,\r\n    LTileLayer,\r\n    LMarker,\r\n    LControlLayers,\r\n    LTooltip\r\n  },\r\n  data() {\r\n    return {\r\n      zoom:17,      \r\n    };\r\n  },\r\n  methods: {\r\n    log(a) {\r\n      console.log(a);\r\n    },\r\n  }  \r\n};\r\n</script>\r\n\r\n<style lang='scss' scoped>\r\n#map{\r\n    height: 50vh; \r\n    width: 80%;\r\n    margin: 0 auto;\r\n}\r\n</style>","import { render } from \"./Map.vue?vue&type=template&id=d027c380&scoped=true\"\nimport script from \"./Map.vue?vue&type=script&lang=js\"\nexport * from \"./Map.vue?vue&type=script&lang=js\"\n\nimport \"./Map.vue?vue&type=style&index=0&id=d027c380&lang=scss&scoped=true\"\n\nimport exportComponent from \"C:\\\\verstka\\\\vue_cli_icecream\\\\node_modules\\\\vue-loader-v16\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-d027c380\"]])\n\nexport default __exports__","<template>\r\n    <div id=\"feedback\">\r\n        <h4 class=\"feed_back_title\">Have Questions in Mind? Let us help you</h4>\r\n        <form class=\"feedback_form\" @submit.prevent=\"validateAndSend\">            \r\n            <input class=\"input_wrapper\" type=\"text\" placeholder=\"Enter your name\" v-model.trim=\"name\">            \r\n            <input class=\"input_wrapper\" type=\"text\" placeholder=\"Enter your email\" v-model.trim=\"email\">         \r\n            <input class=\"input_wrapper\" v-maska=\"'+38 (0##) ###-##-##'\" type=\"text\" placeholder=\"Enter your phone\" v-model=\"phone\" @blur=\"checkPhoneLength\">           \r\n            <textarea class=\"input_wrapper text_wrapper\" rows=\"10\" placeholder=\"Enter your message...\" v-model.trim=\"message\"></textarea>           \r\n            <button type=\"submit\" class=\"btn\">Send</button>\r\n        </form>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\nimport { maska } from 'maska'\r\nimport axios from 'axios'\r\n\r\nexport default {\r\n    name:\"FeedbackForm\",\r\n    directives: { maska },\r\n    data(){\r\n        return{\r\n            name:'',\r\n            email:'',\r\n            phone:'',            \r\n            message:'',\r\n            BOT_TOKEN:'5060479505:AAE5--JEDUqjudIJcP82clFnIAf1HMRrjA4',      \r\n            CHAT_ID: '-1001765759474'\r\n        }\r\n    },\r\n    methods:{\r\n        checkPhoneLength(){\r\n            if(this.phone.length!==19){\r\n                this.phone == ''\r\n            }\r\n        },\r\n        validateEmail(email){\r\n            // eslint-disable-next-line\r\n            const regexp = /^(([^<>()[\\]\\\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\])|(([a-zA-Z\\-0-9]+\\.)+[a-zA-Z]{2,}))$/\r\n          return email.match(regexp)\r\n        },  \r\n\r\n        validateForm(){\r\n            let valid = true;\r\n            let err_text = [];\r\n\r\n            if(this.name===''){\r\n                valid =false;\r\n                err_text.push('Enter your name')                \r\n            }\r\n            if(this.email===''){\r\n                valid =false;\r\n                err_text.push('Enter your email')\r\n            }else{\r\n                if(!this.validateEmail(this.email)){\r\n                    valid =false;\r\n                    err_text.push('Enter valid email address')\r\n                }\r\n            }\r\n            if(this.phone===''){\r\n                valid =false;\r\n                err_text.push('Enter your phone')\r\n            }          \r\n            if(this.message===''){\r\n                valid =false;\r\n                err_text.push('Enter your message')\r\n            }\r\n            if(!valid){\r\n                this.$toast.error(err_text.join('<br/>'))\r\n            }\r\n            return valid;\r\n        },\r\n        validateAndSend(){\r\n            if(this.validateForm()){\r\n                let text = encodeURI(`Name: ${this.name}\\nEmail: ${this.email}\\nPhone: ${this.phone}\\nMessage: ${this.message}`);\r\n                axios.get(`https://api.telegram.org/bot${this.BOT_TOKEN}/sendMessage?chat_id=${this.CHAT_ID}&text=${text}&parse_mode=html`)\r\n        .then(resp=>{\r\n            if(resp.data.ok){\r\n                this.$toast.success(\"Message successfully send\")\r\n                this.name = '';\r\n                this.email = '';\r\n                this.phone = '';                \r\n                this.message = ''\r\n            }else{\r\n                this.$toast.error(resp.data.description)\r\n            }\r\n        })\r\n          .catch((err)=>{\r\n              this.$toast.error(err)\r\n          })      \r\n\r\n            }            \r\n        }\r\n    }\r\n}\r\n</script>\r\n\r\n<style lang=\"scss\" scoped>\r\n\r\n#feedback{\r\n    display: flex;      \r\n    width: 80%;\r\n    margin: 0 auto 100px;\r\n    flex-direction: column;\r\n    justify-content: center;\r\n    align-items: center;\r\n    border: 1px solid rgba(0, 0, 0, 0.03);\r\n    border-radius: 5px;\r\n    padding: 50px 0;\r\n    box-shadow: 0px 4px 4px rgba(0, 0, 0, 0.25);\r\n}\r\n\r\n.feed_back_title{\r\n    font-size: 26px;\r\n    margin-bottom: 30px;\r\n}\r\n.feedback_form{\r\n    margin: 0 auto;\r\n    width: 70%;\r\n    display: flex;\r\n    flex-direction: column;\r\n    justify-content: center;\r\n    align-items: center;\r\n}\r\n.input_wrapper{\r\n    width: 80%;\r\n    height: 55px;    \r\n    border: 2px solid rgba(214, 67, 116, 0.5);\r\n    border-radius: 5px;\r\n    padding-left: 10px;\r\n    margin-bottom: 15px;        \r\n}\r\n.text_wrapper{\r\n    margin-bottom: 30px;\r\n    padding-top: 16px;\r\n    resize: none;\r\n    height: 100px;\r\n}\r\n</style>","import { render } from \"./FeedbackForm.vue?vue&type=template&id=72e76be5&scoped=true\"\nimport script from \"./FeedbackForm.vue?vue&type=script&lang=js\"\nexport * from \"./FeedbackForm.vue?vue&type=script&lang=js\"\n\nimport \"./FeedbackForm.vue?vue&type=style&index=0&id=72e76be5&lang=scss&scoped=true\"\n\nimport exportComponent from \"C:\\\\verstka\\\\vue_cli_icecream\\\\node_modules\\\\vue-loader-v16\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-72e76be5\"]])\n\nexport default __exports__","import { render } from \"./Contact.vue?vue&type=template&id=7f61ab8d&scoped=true\"\nimport script from \"./Contact.vue?vue&type=script&lang=js\"\nexport * from \"./Contact.vue?vue&type=script&lang=js\"\n\nimport \"./Contact.vue?vue&type=style&index=0&id=7f61ab8d&lang=scss&scoped=true\"\n\nimport exportComponent from \"C:\\\\verstka\\\\vue_cli_icecream\\\\node_modules\\\\vue-loader-v16\\\\dist\\\\exportHelper.js\"\nconst __exports__ = /*#__PURE__*/exportComponent(script, [['render',render],['__scopeId',\"data-v-7f61ab8d\"]])\n\nexport default __exports__"],"sourceRoot":""}